(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-0ee44a66"],{"1fd0":function(e,t,n){"use strict";var a=n("dff1"),s=n.n(a);s.a},"27e7":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("main",{staticClass:"main-content"},[n("h1",[e._v("The Basics of the PacketLab Utility Library")]),n("p",[e._v("At the core of PacketLab is the PacketLab Utility Library, a C99 library containing a code base that can be used to write PacketLab experiments and interface with PacketLab entities like experiment controllers and endpoints. The PacketLab library contains a variety of tools that make writing, executing, and hosting experiments easier. Some functions and objects in the library come in handy for running specific types of experiments, while others help connect experiments to PacketLab endpoints and controllers.")]),n("p",[e._v("This tutorial walks through some of the key elements of the PacketLab library. While this tutorial provides a higher-level overview of some functions and tools that the library offers, the complete Doxygen for the library can be accessed via the DOCS link in the sidebar. The Doxygen contains an outline of all functions and their arguments, structs and their fields, and other elements used in the library code.")]),n("p",[e._v("It may also be very helpful to reference any of the PacketLab sample experiments to see the code referenced in this tutorial being used in the context of an experiment. Different experiments demonstrate different use cases of PacketLab code, as described in "),n("router-link",{attrs:{to:{name:"SampleExps"}},scopedSlots:e._u([{key:"default",fn:function(t){var a=t.route,s=t.href;return[n("u",[n("a",{class:{active:e.currentRouteName==a.name},attrs:{href:s}},[e._v("their tutorial")])])]}}])}),e._v(". After reading this tutorial, you will be better prepared to navigate and understand the documentation and sample tests.")],1),e._m(0),n("h2",[e._v("pktlab.h")]),e._m(1),e._m(2),e._m(3),n("p",[e._v("The header also includes lots of content for more specialized use cases. Some content is more specific to working with the PacketLab library, while other content can be used to facilitate different experiments. There are PacketLab functions and types that deal with time, a bunch of functions for working with keys and certificates, conversion functions between different byte orderings, virtual memory and buffer reading and writing functions, functions for encoding and decoding strings and lists to use with certain descriptors and attributes, and more! All of this additional content can be found in the Documentation.")]),n("h2",[e._v("pktctrl.h")]),e._m(4),e._m(5),e._m(6),e._m(7),e._m(8),n("p",[n("em",[e._v("As previously mentioned, to see the library in action, please explore the sample tests included with the PacketLab bundle or "),n("router-link",{attrs:{to:{name:"SampleExps"}},scopedSlots:e._u([{key:"default",fn:function(t){var a=t.route,s=t.href;return[n("u",[n("a",{class:{active:e.currentRouteName==a.name},attrs:{href:s}},[e._v("their tutorial")])])]}}])}),e._v(", and for a more comprehensive view of all that the PacketLab Utility Library has to offer, check out the Doxygen by clicking on DOCS in the sidebar!")],1)])])},s=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("The two header files in the library are "),n("code",[e._v("pktlab.h")]),e._v(" and "),n("code",[e._v("pktctrl.h")]),e._v(". Let's see what each header file has to offer.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[n("code",[e._v("pktlab.h")]),e._v(" represents the majority of the PacketLab library code. The header contains numerous functions that can be utilized for a variety of different experiments and use cases. It also contains several objects that are fundamental to PacketLab and defines many constants that PacketLab uses.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("A key object defined in the header is the "),n("code",[e._v("pktlab_message")]),e._v(" struct. pktlab message structs contain information that can be used by the entities in a connection. As shown in the Doxygen, the struct itself is actually a union of many different types of structs that correspond to different use cases, and the pktlab message struct morphs into any of these structs depending on what you need it to do. Depending on the type of connection they are being used with, the structs might store IP addresses, ports, information about what protocols are being used, and more.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("The header contains a handful of enums that focus on different groups of constants that are used throughout PacketLab by functions and objects in the library. An example of a basic enum is "),n("code",[e._v("pktlab_message_type")]),e._v(", the enum for message types. This enum contains codes for each message type that are used to determine what kind of message is being handled. Some very useful constants that the header defines are the constants for different protocols, such as "),n("code",[e._v("PKTLAB_IP4_PROTO")]),e._v(", the constant used to denote the usage of IPv4, and "),n("code",[e._v("PKTLAB_TCP_PROTO")]),e._v(", used to denote a TCP socket.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[n("code",[e._v("pktctrl.h")]),e._v(" contains code that is used for communicating between PacketLab entities. Whether it be connecting a controller to an endpoint, or simply sending packets from a socket to a server using PacketLab, "),n("code",[e._v("pktctrl")]),e._v(" (Packet Control) functions enable PacketLab users to handle the transmission of data with ease.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("In PacketLab, communication control takes place within a pktctrl session. A pktctrl session is a control session that PacketLab builds around a connection. PacketLab manages pktctrl sessions using pktctrl objects, which have type "),n("code",[e._v("pktctrl_obj")]),e._v(". The pktctrl object is really just stores any information about the connection the session is being used for. This information can be used by functions that send and receive information, as well as by the entities that are connecting in the session.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("To start a pktctrl session, you can first make a pktctrl object by creating a "),n("code",[e._v("pktctrl_obj *")]),e._v(", then calling the "),n("code",[e._v("pktctrl_create_obj()")]),e._v(" function, which returns a pointer to a pktctrl object. Next, call "),n("code",[e._v("pktctrl_raw_session(int fd, struct pktctrl_obj * ctrlobj)")]),e._v(" with the desired file descriptor and the pktctrl object you just created. And, presto, if the session creation is successful, i.e. the function returns "),n("code",[e._v("PKTCTRL_SUCCESS")]),e._v(" (defined as 0), you now have a pktctrl object linked to a pktctrl session that can be used to send and receive data in PacketLab experiments!")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("blockquote",[e._v("Note that to establish a pktctrl session for a TLS connection, "),n("code",[e._v("pktctrl_connect()")]),e._v(" and "),n("code",[e._v("pktctrl_accept()")]),e._v(" should also be called. These functions do NOT replace the standard "),n("code",[e._v("connect()")]),e._v(" and "),n("code",[e._v("accept()")]),e._v(", they only serve to link the pktctrl session to the TLS connection.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("Once your pktctrl session has been successfully initiated, you can now have all of the functions in "),n("code",[e._v("pktctrl.h")]),e._v(" at your disposal. Two key functions are "),n("code",[e._v("pktctrl_read_message()")]),e._v(" and "),n("code",[e._v("pktctrl_write_message()")]),e._v(". As their names suggest, these functions are used to send and receive pktctrl messages, which transfer data between the entities in a pktctrl session. There are also a handful of read and write functions for more specialized use, such as functions that can parse a number of bytes rather than being limited by a pktctrl message struct. The header also contains several "),n("code",[e._v("select()")]),e._v(" functions, as well as a multitude of functions that can be used to work with key certificates.")])}],o=(n("1fd0"),n("660d"),n("2877")),i={},r=Object(o["a"])(i,a,s,!1,null,"354f69ed",null);t["default"]=r.exports},"660d":function(e,t,n){"use strict";var a=n("6cb6"),s=n.n(a);s.a},"6cb6":function(e,t,n){},dff1:function(e,t,n){}}]);
//# sourceMappingURL=chunk-0ee44a66.js.map